#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define NormRANu (2.3283063671E-10F)
#define normNorm (4.656612873E-10F) ///1/2^31, so that the value of r1279 is never 1
#define NBITM1 31
#define dim 2
#define z 4


unsigned int larueda[256], number = 0;
unsigned char ind_ran, i1, i2, i3;

int secuencia_rand[2048], index1[2048], index2[2048], iaux;


void ini_ran(int seed);
double Rand(void);

void crea_lista_vecinos(int** vecinos, int L, int N);
void muestra_lista(int **vecinos, int N);
void genera_output(double* times, double* eners, double* magnets, int N_medidas, int N, char *name_file);
void lee_input(int *L_dir, double *T_dir, int *n_mcs_dir, int *n_meas_dir, int *seed_dir, char *name_file);
void measure_observables(char *spins, int N, int **vecinos, double *eners, double *magnets, int index);
void lee_configuracion(char *spins, int N, char *name_file);
void mc_step(char *spins, int N, int **vecinos, double *probs);
void ini_r1279();
double r1279(void);
void snapshot(char *spins, int L);
void genera_registro(char *spins, int **vecinos, int *registro, int *g, int N);
void actualiza_registro(int spin_index, int old_class, int *registro, int *g, int **vecinos, char *spins);
void genera_acumulada(double *probs, int *g, double *acumulada);
int rnd_from_a_class(int the_class, int *g, int *registro, int N);
void CTMC_step(double *t_dir, char *spins, int **vecinos, int N, int *registro, int *g, double *probs, double *acumulada);





int main()
{

    double T, factor;
    int i,j, L, N, n_mcs, n_pasos;

    ///we initialize the parameters
    T = 1.0; ///temperature
    L = 20; ///linear size of the spin lattice
    N = L*L; ///number of spins
    n_mcs = 1000; ///number of Monte Carlo steps we want to simulate via CTMC (we want t/N to get bigger than this)
    n_pasos = n_mcs*N; ///number of steps of our CTMC simulation


    ///we initialize the RNG with some seed
    ini_ran(523456789);
    ini_r1279();

    ///we declare the array of spins, the neighbours list, and the arrays that store the measurements of m and E
    char* spins = (char*) malloc(N*sizeof(char));
    int **vecinos = (int**) malloc(N*sizeof(int*)); ///nbr list
    for(i=0; i<N; i++)  vecinos[i] = (int*) malloc(z*sizeof(int));
    double *eners = (double*) malloc(n_pasos*sizeof(double));
    double *magnets = (double*) malloc(n_pasos*sizeof(double));

    ///we create vectors and matrices necessary for CTMC algorithm
    int *registro = (int*)malloc(N*sizeof(int)); ///this stores the class to which each spin belongs
    double acumulada[5]; ///cumulative distribution of the classes
    int g[5]; ///this vector counts how many spins there are of each class
    double *times = (double*) malloc(n_pasos*sizeof(double)); ///this vector stores the time values generated by the CTMC algorithm
    double t; ///time variable

    for(i=0; i<5; i++) g[i] = 0;



    ///we initialize the lattice geometry and the initial configuration:
    crea_lista_vecinos(vecinos, L, N); ///this creates the nbr list for a square lattice with PBC
    //muestra_lista(vecinos, N);
    for(i=0; i<N; i++)
    {
        if(Rand()>0.5) spins[i] = 1;
        else spins[i] = -1;
    } ///random initial configuration



    ///we generate the probability vector
    double* probs = (double*) malloc((z+1)*sizeof(double));
    factor = exp(-4.0/T);
    probs[z/2] = 1.0;
    for(i=1; i<=(z/2); i++)
    {
        probs[z/2-i] = probs[z/2-i+1]/factor;
        probs[z/2+i] = probs[z/2+i-1]*factor;
    }
    for(i=0; i<(z+1); i++) printf("%lf\n", probs[i]);

    ///we impose zero temperature (optional)
    for(i=0; i<(z+1); i++)
    {
        if(probs[i]>1.0) probs[i] = 1.0;
        //else probs[i] = 0.0;  ///uncomment to impose zero temperature
    }


    genera_registro(spins, vecinos, registro, g, N);

    ///we run the simulation
    t=0;  ///time variable
    for(i=0; i<n_pasos; i++)
    {
        CTMC_step(&t, spins, vecinos, N, registro, g, probs, acumulada);
        measure_observables(spins, N, vecinos, eners, magnets, i);
        //printf("%lf\n", t);
        times[i] = t/N; ///time variable expressed in MC steps
        //printf("%d\n", j);
    }

    //for(i=0; i<N; i++) printf("%d\n", spins[i]);
    snapshot(spins, L);


    ///we generate the output:
    genera_output(times, eners, magnets, n_pasos, N, "evolution_CTMC.txt");



    for(i=0; i<N; i++) free(vecinos[i]);
    free(registro);
    free(vecinos);
    free(spins);
    free(eners);
    free(magnets);
    free(probs);
    free(times);



    return 0;
}


void ini_ran(int seed)
{
    int INI, FACTOR, SUM, i;
    INI = seed;
    FACTOR = 67397;
    SUM = 7364893;

    for(i=0; i<256; i++)
    {
        INI = (INI*FACTOR + SUM);
        larueda[i] = INI;
    }
    ind_ran = i1 = i2 = i3 = 0;
}

double Rand(void)
{
    double r;
    i1 = ind_ran-24;
    i2 = ind_ran-55;
    i3 = ind_ran-61;
    larueda[ind_ran] = larueda[i1] + larueda[i2];
    number = (larueda[ind_ran]^larueda[i3]);
    ind_ran++;
    r = number*NormRANu;
    return r;
}

void crea_lista_vecinos(int** vecinos, int L, int N)
{
    int x, y, index, aux;
    for(x=0; x<L; x++) for(y=0; y<L; y++)
    {
        index = x + L*y;
        vecinos[index][0] = index + L; ///vecino de arriba
        vecinos[index][1] = index + 1; ///vecino de la derecha
        vecinos[index][2] = index - L; ///vecino de abajo
        vecinos[index][3] = index -1; ///vecino de la izquierda
    }

    for(index=0; index<N; index++)
    {
        vecinos[index][0] -= floor(((double)vecinos[index][0])/N)*N;
        vecinos[index][2] = vecinos[index][2] - floor(((double)vecinos[index][2])/N)*N;

        aux = vecinos[index][1]-floor((double)index/L)*L;
        aux-= floor((double)aux/L)*L;
        vecinos[index][1] = floor((double)index/L)*L + aux;

        aux = vecinos[index][3]-floor((double)index/L)*L;
        aux-= floor((double)aux/L)*L;
        vecinos[index][3] = floor((double)index/L)*L + aux;

    }
}

void muestra_lista(int **vecinos, int N)
{
    int i,j;
    for(i=0; i<N; i++)
    {
        printf("%d   ", i);
        for(j=0; j<z; j++) printf("%d ", vecinos[i][j]);
        printf("\n");
    }
}

void genera_output(double* times, double* eners, double* magnets, int N_medidas, int N, char *name_file)
{
    int i;
    FILE *f = fopen(name_file, "wt");
    if(f==NULL) exit(2);
    for(i=0; i<N_medidas; i++) fprintf(f, "%lf %lf %lf\n", times[i]/N, eners[i], magnets[i]);
    fclose(f);
}


void measure_observables(char *spins, int N, int **vecinos, double *eners, double *magnets, int index)
{
    int i, e;
    double energia, imanacion;
    energia = imanacion = 0.0;
    for(i=0; i<N; i++)
    {
        imanacion += spins[i];
        //eneriga-=spins[i]*(spins[vecinos[i][0]]+spins[vecinos[i][1]]); ///optimizado
        for(e=0; e<z; e++) energia-=0.5*spins[i]*spins[vecinos[i][e]]; ///generalizado
    }
    eners[index] = energia;
    magnets[index] = imanacion;
}



void ini_r1279()
{
    int i,j, one_bit;

    iaux = 0;
    for(i=0; i<2048; i++)
    {
        index1[i] = (i-1279)&2047;
        index2[i] = (i-418)&2047;

        secuencia_rand[i] = 0;
        for(j=0; j<=NBITM1; j++)
        {
            one_bit = 0;
            if(Rand()>0.5) one_bit = 1;

            one_bit = one_bit << j; ///we shift j places to the left
            secuencia_rand[i] = secuencia_rand[i]|one_bit; ///hacemos un or bit a bit
        }
        secuencia_rand[i] = 2*secuencia_rand[i] + 1;
    }
}

double r1279(void)
{
    int numerin;
    iaux = (iaux+1)&2047;
    secuencia_rand[iaux] = secuencia_rand[index1[iaux]]*secuencia_rand[index2[iaux]];
    numerin = (secuencia_rand[iaux]>>1)&2147483647;
    return ((double)numerin)*normNorm;
}

void snapshot(char *spins, int L)
{
    int i, j, index;
    FILE *f;
    f = fopen("snapshot_ising.txt", "wt");
    if(f==NULL) exit(18);

    for(i=0; i<L; i++)
    {
        for(j=0; j<L; j++) fprintf(f, "%d ", spins[i*L+j]);
        fprintf(f, "\n");
    }
    fclose(f);
}

void genera_registro(char *spins, int **vecinos, int *registro, int *g, int N)
{
    int i, j, vecinos_iguales;
    for(i=0; i<N; i++)
    {
        vecinos_iguales = 0;
        for(j=0; j<z; j++) vecinos_iguales+=spins[vecinos[i][j]];
        vecinos_iguales = spins[i]*vecinos_iguales + z;
        vecinos_iguales/=2;
        registro[i] = vecinos_iguales;
        g[vecinos_iguales]++;

    }
}

void actualiza_registro(int spin_index, int old_class, int *registro, int *g, int **vecinos, char *spins)
{
    int i, new_class;
    new_class = z - old_class;

    ///cambia el estado del spin:
    registro[spin_index] = new_class;
    g[old_class]--;
    g[new_class]++;

    ///cambia el estado de los vecinos del spin
    for(i=0; i<z; i++)
    {
        g[registro[vecinos[spin_index][i]]]--;
        registro[vecinos[spin_index][i]] += spins[spin_index]*spins[vecinos[spin_index][i]];
        g[registro[vecinos[spin_index][i]]]++;
    }

}

void genera_acumulada(double *probs, int *g, double *acumulada)
{
    int i;
    acumulada[0] = g[0]*probs[0];
    for(i=1; i<5; i++) acumulada[i] = acumulada[i-1] + g[i]*probs[i];
}

int rnd_from_a_class(int the_class, int *g, int *registro, int N)
{
    int i, iran, n_visited_members;


    do
    {
        iran = g[the_class]*r1279();
    } while(iran == g[the_class]);

    iran++;
    n_visited_members=0;
    for(i=0; (i<N) && (n_visited_members<iran); i++) if(registro[i]==the_class) n_visited_members++;

    return i-1;

}

void CTMC_step(double *t_dir, char *spins, int **vecinos, int N, int *registro, int *g, double *probs, double *acumulada)
{
    double Q_tilde, delta_t, omega;
    int l, i;

    Q_tilde = 0.0;
    for(i=0; i<5; i++) Q_tilde += g[i]*probs[i];
    Q_tilde/=N;
    Q_tilde = 1.0 - Q_tilde;
    genera_acumulada(probs, g, acumulada);

    if(g[3]+g[4]<N) ///this condition is for the program not to get stuck at zero temperature
    {
        delta_t = 1.0 + floor(log(r1279())/log(Q_tilde));
        //printf("delta_t = %lf\n", delta_t);
        omega = acumulada[4]*r1279();
        for(i=4; i>=0; i--)
            if(omega<acumulada[i]) l = i;

        //for(i=0;i<5; i++) printf("%d %lf\n", g[i], acumulada[i]);

        i = rnd_from_a_class(l, g, registro, N);
        spins[i] = -spins[i];
        actualiza_registro(i, l, registro, g, vecinos, spins);
    }
    else delta_t = 1.0;
    (*t_dir) += delta_t;


}











